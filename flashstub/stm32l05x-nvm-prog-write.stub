// 
// stm32l05x-nvm-prog-write.o:     file format elf32-littlearm
// 
// 
// Disassembly of section .text:
// 
// 00000000 <stm32l05x_nvm_prog_write>:
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   "0:");
  [0x0/2] = 0xe00a, //    0:	e00a      	b.n	18 <stm32l05x_nvm_prog_write+0x18>
  [0x2/2] = 0x46c0, //    2:	46c0      	nop			; (mov r8, r8)
// 	...
// #define Nvm(nvm) (*reinterpret_cast<STM32::NVM*>(nvm))
// #define Info (*reinterpret_cast<stm32lx_nvm_stub_info*>(STM32Lx_STUB_INFO_PHYS))
// 
// namespace {
//   inline __attribute((always_inline)) bool unlock (STM32::NVM& nvm) {
//     nvm.pecr      = STM32Lx_NVM_PECR_PELOCK; // Lock to guarantee unlock
  [0x18/2] = 0x2201, //   18:	2201      	movs	r2, #1
// 
//   auto& nvm = Nvm (Info.nvm);
  [0x1a/2] = 0x4b2a, //   1a:	4b2a      	ldr	r3, [pc, #168]	; (c4 <stm32l05x_nvm_prog_write+0xc4>)
  [0x1c/2] = 0x68d9, //   1c:	68d9      	ldr	r1, [r3, #12]
  [0x1e/2] = 0x604a, //   1e:	604a      	str	r2, [r1, #4]
//     nvm.pkeyr     = STM32::NVM::PKEY1;
  [0x20/2] = 0x4a29, //   20:	4a29      	ldr	r2, [pc, #164]	; (c8 <stm32l05x_nvm_prog_write+0xc8>)
  [0x22/2] = 0x60ca, //   22:	60ca      	str	r2, [r1, #12]
//     nvm.pkeyr     = STM32::NVM::PKEY2;
  [0x24/2] = 0x4a29, //   24:	4a29      	ldr	r2, [pc, #164]	; (cc <stm32l05x_nvm_prog_write+0xcc>)
  [0x26/2] = 0x60ca, //   26:	60ca      	str	r2, [r1, #12]
//     nvm.prgkeyr   = STM32::NVM::PRGKEY1;
  [0x28/2] = 0x4a29, //   28:	4a29      	ldr	r2, [pc, #164]	; (d0 <stm32l05x_nvm_prog_write+0xd0>)
  [0x2a/2] = 0x610a, //   2a:	610a      	str	r2, [r1, #16]
//     nvm.prgkeyr   = STM32::NVM::PRGKEY2;
  [0x2c/2] = 0x4a29, //   2c:	4a29      	ldr	r2, [pc, #164]	; (d4 <stm32l05x_nvm_prog_write+0xd4>)
  [0x2e/2] = 0x610a, //   2e:	610a      	str	r2, [r1, #16]
//     return !(nvm.pecr & STM32Lx_NVM_PECR_PRGLOCK);
  [0x30/2] = 0x684a, //   30:	684a      	ldr	r2, [r1, #4]
// 
//   if (!unlock (nvm))
  [0x32/2] = 0x0792, //   32:	0792      	lsls	r2, r2, #30
  [0x34/2] = 0xd502, //   34:	d502      	bpl.n	3c <stm32l05x_nvm_prog_write+0x3c>
//   }
//   inline __attribute((always_inline)) void lock (STM32::NVM& nvm) {
//     nvm.pecr      = STM32Lx_NVM_PECR_PELOCK; }
  [0x36/2] = 0x2301, //   36:	2301      	movs	r3, #1
  [0x38/2] = 0x604b, //   38:	604b      	str	r3, [r1, #4]
//     }
//   }
// 
// quit:
//   lock (nvm);
//   __asm volatile ("bkpt");
  [0x3a/2] = 0xbe00, //   3a:	be00      	bkpt	0x0000
//   auto& nvm = Nvm (Info.nvm);
// 
//   if (!unlock (nvm))
//     goto quit;
// 
//   nvm.sr = STM32Lx_NVM_SR_ERR_M; // Clear errors
  [0x3c/2] = 0x4826, //   3c:	4826      	ldr	r0, [pc, #152]	; (d8 <stm32l05x_nvm_prog_write+0xd8>)
  [0x3e/2] = 0x6188, //   3e:	6188      	str	r0, [r1, #24]
// 
//   while (Info.size > 0) {
  [0x40/2] = 0x685d, //   40:	685d      	ldr	r5, [r3, #4]
  [0x42/2] = 0x4e20, //   42:	4e20      	ldr	r6, [pc, #128]	; (c4 <stm32l05x_nvm_prog_write+0xc4>)
  [0x44/2] = 0x2d00, //   44:	2d00      	cmp	r5, #0
  [0x46/2] = 0xddf6, //   46:	ddf6      	ble.n	36 <stm32l05x_nvm_prog_write+0x36>
// 
//     // Either we're not half-page aligned or we have less than a half
//     // page to write
//     if (Info.size < Info.page_size/2
  [0x48/2] = 0x8a32, //   48:	8a32      	ldrh	r2, [r6, #16]
  [0x4a/2] = 0x0852, //   4a:	0852      	lsrs	r2, r2, #1
  [0x4c/2] = 0x1e54, //   4c:	1e54      	subs	r4, r2, #1
  [0x4e/2] = 0x4295, //   4e:	4295      	cmp	r5, r2
  [0x50/2] = 0xdb02, //   50:	db02      	blt.n	58 <stm32l05x_nvm_prog_write+0x58>
//         || (reinterpret_cast<uint32_t> (Info.destination)
  [0x52/2] = 0x6837, //   52:	6837      	ldr	r7, [r6, #0]
  [0x54/2] = 0x4227, //   54:	4227      	tst	r7, r4
  [0x56/2] = 0xd01d, //   56:	d01d      	beq.n	94 <stm32l05x_nvm_prog_write+0x94>
//             & (Info.page_size/2 - 1))) {
//       nvm.pecr = (Info.options & OPT_STM32L1) ? 0
//         : STM32Lx_NVM_PECR_PROG; // Word programming
  [0x58/2] = 0x2602, //   58:	2602      	movs	r6, #2
//     // Either we're not half-page aligned or we have less than a half
//     // page to write
//     if (Info.size < Info.page_size/2
//         || (reinterpret_cast<uint32_t> (Info.destination)
//             & (Info.page_size/2 - 1))) {
//       nvm.pecr = (Info.options & OPT_STM32L1) ? 0
  [0x5a/2] = 0x8a5f, //   5a:	8a5f      	ldrh	r7, [r3, #18]
//         : STM32Lx_NVM_PECR_PROG; // Word programming
  [0x5c/2] = 0x4037, //   5c:	4037      	ands	r7, r6
  [0x5e/2] = 0x427e, //   5e:	427e      	negs	r6, r7
  [0x60/2] = 0x417e, //   60:	417e      	adcs	r6, r7
  [0x62/2] = 0x00f6, //   62:	00f6      	lsls	r6, r6, #3
  [0x64/2] = 0x604e, //   64:	604e      	str	r6, [r1, #4]
//       size_t c = Info.page_size/2
//         - (reinterpret_cast<uint32_t> (Info.destination)
//            & (Info.page_size/2 - 1));
  [0x66/2] = 0x681e, //   66:	681e      	ldr	r6, [r3, #0]
  [0x68/2] = 0x4034, //   68:	4034      	ands	r4, r6
  [0x6a/2] = 0x1b12, //   6a:	1b12      	subs	r2, r2, r4
  [0x6c/2] = 0x42aa, //   6c:	42aa      	cmp	r2, r5
  [0x6e/2] = 0xd900, //   6e:	d900      	bls.n	72 <stm32l05x_nvm_prog_write+0x72>
  [0x70/2] = 0x1c2a, //   70:	1c2a      	adds	r2, r5, #0
//       if (c > Info.size)
//         c = Info.size;
//       Info.size -= c;
  [0x72/2] = 0x1aad, //   72:	1aad      	subs	r5, r5, r2
  [0x74/2] = 0x605d, //   74:	605d      	str	r5, [r3, #4]
//       c /= 4;
  [0x76/2] = 0x0892, //   76:	0892      	lsrs	r2, r2, #2
//       while (c--) {
  [0x78/2] = 0x3a01, //   78:	3a01      	subs	r2, #1
  [0x7a/2] = 0xd3e1, //   7a:	d3e1      	bcc.n	40 <stm32l05x_nvm_prog_write+0x40>
//         uint32_t v = *Info.source++;
  [0x7c/2] = 0x689c, //   7c:	689c      	ldr	r4, [r3, #8]
  [0x7e/2] = 0x1d25, //   7e:	1d25      	adds	r5, r4, #4
  [0x80/2] = 0x609d, //   80:	609d      	str	r5, [r3, #8]
  [0x82/2] = 0x6825, //   82:	6825      	ldr	r5, [r4, #0]
//         *Info.destination++ = v;
  [0x84/2] = 0x681c, //   84:	681c      	ldr	r4, [r3, #0]
  [0x86/2] = 0x1d26, //   86:	1d26      	adds	r6, r4, #4
  [0x88/2] = 0x601e, //   88:	601e      	str	r6, [r3, #0]
  [0x8a/2] = 0x6025, //   8a:	6025      	str	r5, [r4, #0]
//         if (nvm.sr & STM32Lx_NVM_SR_ERR_M)
  [0x8c/2] = 0x698c, //   8c:	698c      	ldr	r4, [r1, #24]
  [0x8e/2] = 0x4204, //   8e:	4204      	tst	r4, r0
  [0x90/2] = 0xd0f2, //   90:	d0f2      	beq.n	78 <stm32l05x_nvm_prog_write+0x78>
  [0x92/2] = 0xe7d0, //   92:	e7d0      	b.n	36 <stm32l05x_nvm_prog_write+0x36>
//           goto quit;
//       }
//     }
//     // Or we are writing a half-page(s)
//     else {
//       nvm.pecr = STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_FPRG; // Half-page prg
  [0x94/2] = 0x2481, //   94:	2481      	movs	r4, #129	; 0x81
//       size_t c = Info.size & ~(Info.page_size/2 - 1);
  [0x96/2] = 0x4252, //   96:	4252      	negs	r2, r2
  [0x98/2] = 0x402a, //   98:	402a      	ands	r2, r5
//       Info.size -= c;
  [0x9a/2] = 0x1aad, //   9a:	1aad      	subs	r5, r5, r2
//           goto quit;
//       }
//     }
//     // Or we are writing a half-page(s)
//     else {
//       nvm.pecr = STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_FPRG; // Half-page prg
  [0x9c/2] = 0x00e4, //   9c:	00e4      	lsls	r4, r4, #3
  [0x9e/2] = 0x604c, //   9e:	604c      	str	r4, [r1, #4]
//       size_t c = Info.size & ~(Info.page_size/2 - 1);
//       Info.size -= c;
//       c /= 4;
  [0xa0/2] = 0x0892, //   a0:	0892      	lsrs	r2, r2, #2
//     }
//     // Or we are writing a half-page(s)
//     else {
//       nvm.pecr = STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_FPRG; // Half-page prg
//       size_t c = Info.size & ~(Info.page_size/2 - 1);
//       Info.size -= c;
  [0xa2/2] = 0x6075, //   a2:	6075      	str	r5, [r6, #4]
//       c /= 4;
//       while (c--) {
  [0xa4/2] = 0x3a01, //   a4:	3a01      	subs	r2, #1
  [0xa6/2] = 0xd308, //   a6:	d308      	bcc.n	ba <stm32l05x_nvm_prog_write+0xba>
//         uint32_t v = *Info.source++;
  [0xa8/2] = 0x689c, //   a8:	689c      	ldr	r4, [r3, #8]
  [0xaa/2] = 0x1d25, //   aa:	1d25      	adds	r5, r4, #4
  [0xac/2] = 0x609d, //   ac:	609d      	str	r5, [r3, #8]
  [0xae/2] = 0x6825, //   ae:	6825      	ldr	r5, [r4, #0]
//         *Info.destination++ = v;
  [0xb0/2] = 0x681c, //   b0:	681c      	ldr	r4, [r3, #0]
  [0xb2/2] = 0x1d26, //   b2:	1d26      	adds	r6, r4, #4
  [0xb4/2] = 0x601e, //   b4:	601e      	str	r6, [r3, #0]
  [0xb6/2] = 0x6025, //   b6:	6025      	str	r5, [r4, #0]
  [0xb8/2] = 0xe7f4, //   b8:	e7f4      	b.n	a4 <stm32l05x_nvm_prog_write+0xa4>
//       }
//       if (nvm.sr & STM32Lx_NVM_SR_ERR_M)
  [0xba/2] = 0x698a, //   ba:	698a      	ldr	r2, [r1, #24]
  [0xbc/2] = 0x4202, //   bc:	4202      	tst	r2, r0
  [0xbe/2] = 0xd0bf, //   be:	d0bf      	beq.n	40 <stm32l05x_nvm_prog_write+0x40>
  [0xc0/2] = 0xe7b9, //   c0:	e7b9      	b.n	36 <stm32l05x_nvm_prog_write+0x36>
  [0xc2/2] = 0x46c0, //   c2:	46c0      	nop			; (mov r8, r8)
  [0xc4/2] = 0x0004, //   c4:	20000004 	.word	0x20000004
  [0xc4/2 + 1] = 0x2000,
  [0xc8/2] = 0xcdef, //   c8:	89abcdef 	.word	0x89abcdef
  [0xc8/2 + 1] = 0x89ab,
  [0xcc/2] = 0x0405, //   cc:	02030405 	.word	0x02030405
  [0xcc/2 + 1] = 0x0203,
  [0xd0/2] = 0xaebf, //   d0:	8c9daebf 	.word	0x8c9daebf
  [0xd0/2 + 1] = 0x8c9d,
  [0xd4/2] = 0x1516, //   d4:	13141516 	.word	0x13141516
  [0xd4/2 + 1] = 0x1314,
  [0xd8/2] = 0x0700, //   d8:	00010700 	.word	0x00010700
  [0xd8/2 + 1] = 0x0001,
